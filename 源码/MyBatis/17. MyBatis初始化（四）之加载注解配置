## 1. æ¦‚è¿°

æœ¬æ–‡æ¥ [ã€Šç²¾å°½ MyBatis æºç åˆ†æ â€”â€” MyBatis åˆå§‹åŒ–ï¼ˆä¸‰ï¼‰ä¹‹åŠ è½½ Statement é…ç½®ã€‹](http://svip.iocoder.cn/MyBatis/builder-package-3) ä¸€æ–‡ï¼Œæ¥åˆ†äº« MyBatis åˆå§‹åŒ–çš„ç¬¬ 2 æ­¥çš„ä¸€éƒ¨åˆ†ï¼Œ**åŠ è½½æ³¨è§£é…ç½®**ã€‚è€Œè¿™ä¸ªéƒ¨åˆ†çš„å…¥å£æ˜¯ MapperAnnotationBuilder ã€‚ä¸‹é¢ï¼Œæˆ‘ä»¬ä¸€èµ·æ¥çœ‹çœ‹å®ƒçš„ä»£ç å®ç°ã€‚

åœ¨ [ã€Šç²¾å°½ MyBatis æºç åˆ†æ â€”â€” MyBatis åˆå§‹åŒ–ï¼ˆäºŒï¼‰ä¹‹åŠ è½½ Mapper æ˜ å°„é…ç½®æ–‡ä»¶ã€‹](http://svip.iocoder.cn/MyBatis/builder-package-2) çš„ [ã€Œ3.3.13 mapperElementã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ä¸­ï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ°å¯¹ MapperAnnotationBuilder çš„è°ƒç”¨ä»£ç ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// Configuration.java
    
public <T> void addMapper(Class<T> type) {
    mapperRegistry.addMapper(type);
}

// MapperRegistry.java

public <T> void addMapper(Class<T> type) {
    // åˆ¤æ–­ï¼Œå¿…é¡»æ˜¯æ¥å£ã€‚
    if (type.isInterface()) {
        // å·²ç»æ·»åŠ è¿‡ï¼Œåˆ™æŠ›å‡º BindingException å¼‚å¸¸
        if (hasMapper(type)) {
            throw new BindingException("Type " + type + " is already known to the MapperRegistry.");
        }
        boolean loadCompleted = false;
        try {
            // æ·»åŠ åˆ° knownMappers ä¸­
            knownMappers.put(type, new MapperProxyFactory<>(type));
            // It's important that the type is added before the parser is run
            // otherwise the binding may automatically be attempted by the
            // mapper parser. If the type is already known, it won't try.
            // è§£æ Mapper çš„æ³¨è§£é…ç½® <====== ğŸ˜ˆ çœ‹æˆ‘ ğŸ˜ˆ =====>
            MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
            parser.parse();
            // æ ‡è®°åŠ è½½å®Œæˆ
            loadCompleted = true;
        } finally {
            // è‹¥åŠ è½½æœªå®Œæˆï¼Œä» knownMappers ä¸­ç§»é™¤
            if (!loadCompleted) {
                knownMappers.remove(type);
            }
        }
    }
}
```

## 2. MapperAnnotationBuilder

`org.apache.ibatis.builder.annotation.MapperAnnotationBuilder` ï¼ŒMapper æ³¨è§£æ„é€ å™¨ï¼Œè´Ÿè´£è§£æ Mapper æ¥å£ä¸Šçš„æ³¨è§£ã€‚

### 2.1 æ„é€ æ–¹æ³•

```java
// MapperAnnotationBuilder.java

/**
 * SQL æ“ä½œæ³¨è§£é›†åˆ
 */
private static final Set<Class<? extends Annotation>> SQL_ANNOTATION_TYPES = new HashSet<>();
/**
 * SQL æ“ä½œæä¾›è€…æ³¨è§£é›†åˆ
 */
private static final Set<Class<? extends Annotation>> SQL_PROVIDER_ANNOTATION_TYPES = new HashSet<>();

private final Configuration configuration;
private final MapperBuilderAssistant assistant;
/**
 * Mapper æ¥å£ç±»
 */
private final Class<?> type;

static {
    SQL_ANNOTATION_TYPES.add(Select.class);
    SQL_ANNOTATION_TYPES.add(Insert.class);
    SQL_ANNOTATION_TYPES.add(Update.class);
    SQL_ANNOTATION_TYPES.add(Delete.class);

    SQL_PROVIDER_ANNOTATION_TYPES.add(SelectProvider.class);
    SQL_PROVIDER_ANNOTATION_TYPES.add(InsertProvider.class);
    SQL_PROVIDER_ANNOTATION_TYPES.add(UpdateProvider.class);
    SQL_PROVIDER_ANNOTATION_TYPES.add(DeleteProvider.class);
}

public MapperAnnotationBuilder(Configuration configuration, Class<?> type) {
    // åˆ›å»º MapperBuilderAssistant å¯¹è±¡
    String resource = type.getName().replace('.', '/') + ".java (best guess)";
    this.assistant = new MapperBuilderAssistant(configuration, resource);
    this.configuration = configuration;
    this.type = type;
}
```

### 2.2 parse

`#parse()` æ–¹æ³•ï¼Œè§£ææ³¨è§£ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

public void parse() {
    // <1> åˆ¤æ–­å½“å‰ Mapper æ¥å£æ˜¯å¦åº”åŠ è½½è¿‡ã€‚
    String resource = type.toString();
    if (!configuration.isResourceLoaded(resource)) {
        // <2> åŠ è½½å¯¹åº”çš„ XML Mapper
        loadXmlResource();
        // <3> æ ‡è®°è¯¥ Mapper æ¥å£å·²ç»åŠ è½½è¿‡
        configuration.addLoadedResource(resource);
        // <4> è®¾ç½® namespace å±æ€§
        assistant.setCurrentNamespace(type.getName());
        // <5> è§£æ @CacheNamespace æ³¨è§£
        parseCache();
        // <6> è§£æ @CacheNamespaceRef æ³¨è§£
        parseCacheRef();
        // <7> éå†æ¯ä¸ªæ–¹æ³•ï¼Œè§£æå…¶ä¸Šçš„æ³¨è§£
        Method[] methods = type.getMethods();
        for (Method method : methods) {
            try {
                // issue #237
                if (!method.isBridge()) {
                    // <7.1> æ‰§è¡Œè§£æ
                    parseStatement(method);
                }
            } catch (IncompleteElementException e) {
                // <7.2> è§£æå¤±è´¥ï¼Œæ·»åŠ åˆ° configuration ä¸­
                configuration.addIncompleteMethod(new MethodResolver(this, method));
            }
        }
    }
    // <8> è§£æå¾…å®šçš„æ–¹æ³•
    parsePendingMethods();
}
```

`<1>` å¤„ï¼Œè°ƒç”¨ `Configuration#isResourceLoaded(String resource)` æ–¹æ³•ï¼Œåˆ¤æ–­å½“å‰ Mapper æ¥å£æ˜¯å¦åº”åŠ è½½è¿‡ã€‚

`<2>` å¤„ï¼Œè°ƒç”¨ `#loadXmlResource()` æ–¹æ³•ï¼ŒåŠ è½½å¯¹åº”çš„ XML Mapper ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.3 loadXmlResourceã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

`<3>` å¤„ï¼Œè°ƒç”¨ `Configuration#addLoadedResource(String resource)` æ–¹æ³•ï¼Œæ ‡è®°è¯¥ Mapper æ¥å£å·²ç»åŠ è½½è¿‡ã€‚

`<4>` å¤„ï¼Œè°ƒç”¨ `MapperBuilderAssistant#setCurrentNamespace(String currentNamespace)` æ–¹æ³•ï¼Œè®¾ç½® `namespace` å±æ€§ã€‚

`<5>` å¤„ï¼Œè°ƒç”¨ `#parseCache()` æ–¹æ³•ï¼Œ`@CacheNamespace` æ³¨è§£ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.4 parseCacheã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

`<6>` å¤„ï¼Œè°ƒç”¨ `#parseCacheRef()` æ–¹æ³•ï¼Œ`@CacheNamespaceRef` æ³¨è§£ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.5 parseCacheRefã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

`<7>` å¤„ï¼Œéå†æ¯ä¸ªæ–¹æ³•ï¼Œè§£æå…¶ä¸Šçš„æ³¨è§£ã€‚

`<7.1>` å¤„ï¼Œè°ƒç”¨ `#parseStatement(Method method)` æ–¹æ³•ï¼Œæ‰§è¡Œè§£ææ¯ä¸ªæ–¹æ³•çš„æ³¨è§£ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.6 parseStatementã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

`<7.2>` å¤„ï¼Œè§£æå¤±è´¥ï¼Œè°ƒç”¨ `Configuration#addIncompleteMethod(MethodResolver builder)` æ–¹æ³•ï¼Œæ·»åŠ åˆ° `configuration` ä¸­ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// Configuration.java

/**
 * æœªå®Œæˆçš„ MethodResolver é›†åˆ
 */
protected final Collection<MethodResolver> incompleteMethods = new LinkedList<>();

public void addIncompleteMethod(MethodResolver builder) {
    incompleteMethods.add(builder);
}
```

å…³äº MethodResolver ç±»ï¼Œè¯¦ç»†è§£æï¼Œè§ [ã€Œ2.7 MethodResolverã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

`<8>` å¤„ï¼Œè°ƒç”¨ `#parsePendingMethods()` æ–¹æ³•ï¼Œè§£æå¾…å®šçš„æ–¹æ³•ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.8 parsePendingMethodsã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

### 2.3 loadXmlResource

`#loadXmlResource()` æ–¹æ³•ï¼ŒåŠ è½½å¯¹åº”çš„ XML Mapper ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private void loadXmlResource() {
    // Spring may not know the real resource name so we check a flag
    // to prevent loading again a resource twice
    // this flag is set at XMLMapperBuilder#bindMapperForNamespace
    // <1> åˆ¤æ–­ Mapper XML æ˜¯å¦å·²ç»åŠ è½½è¿‡ï¼Œå¦‚æœåŠ è½½è¿‡ï¼Œå°±ä¸åŠ è½½äº†ã€‚
    // æ­¤å¤„ï¼Œæ˜¯ä¸ºäº†é¿å…å’Œ XMLMapperBuilder#parse() æ–¹æ³•å†²çªï¼Œé‡å¤è§£æ
    if (!configuration.isResourceLoaded("namespace:" + type.getName())) {
        // <2> è·å¾— InputStream å¯¹è±¡
        String xmlResource = type.getName().replace('.', '/') + ".xml";
        // #1347
        InputStream inputStream = type.getResourceAsStream("/" + xmlResource);
        if (inputStream == null) {
            // Search XML mapper that is not in the module but in the classpath.
            try {
                inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);
            } catch (IOException e2) {
                // ignore, resource is not required
            }
        }
        // <2> åˆ›å»º XMLMapperBuilder å¯¹è±¡ï¼Œæ‰§è¡Œè§£æ
        if (inputStream != null) {
            XMLMapperBuilder xmlParser = new XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());
            xmlParser.parse();
        }
    }
}
```

`<1>` å¤„ï¼Œåˆ¤æ–­ Mapper XML æ˜¯å¦å·²ç»åŠ è½½è¿‡ï¼Œå¦‚æœåŠ è½½è¿‡ï¼Œå°±ä¸åŠ è½½äº†ã€‚æ­¤å¤„ï¼Œæ˜¯ä¸ºäº†é¿å…å’Œ `XMLMapperBuilder#parse()` æ–¹æ³•å†²çªï¼Œé‡å¤è§£æã€‚

`<2>` å¤„ï¼Œè·å¾— InputStream å¯¹è±¡ï¼Œç„¶ååˆ›å»º XMLMapperBuilder å¯¹è±¡ï¼Œæœ€åè°ƒç”¨ `XMLMapperBuilder#parse()` æ–¹æ³•ï¼Œæ‰§è¡Œè§£æã€‚

è¿™é‡Œï¼Œå¦‚æœæ˜¯å…ˆè§£æ Mapper æ¥å£ï¼Œé‚£å°±ä¼šè¾¾åˆ°å†è§£æå¯¹åº”çš„ Mapper XML çš„æƒ…å†µã€‚

### 2.4 parseCache

`#parseCache()` æ–¹æ³•ï¼Œè§£æ `@CacheNamespace` æ³¨è§£ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private void parseCache() {
    // <1> è·å¾—ç±»ä¸Šçš„ @CacheNamespace æ³¨è§£
    CacheNamespace cacheDomain = type.getAnnotation(CacheNamespace.class);
    if (cacheDomain != null) {
        // <2> è·å¾—å„ç§å±æ€§
        Integer size = cacheDomain.size() == 0 ? null : cacheDomain.size();
        Long flushInterval = cacheDomain.flushInterval() == 0 ? null : cacheDomain.flushInterval();
        // <3> è·å¾— Properties å±æ€§
        Properties props = convertToProperties(cacheDomain.properties());
        // <4> åˆ›å»º Cache å¯¹è±¡
        assistant.useNewCache(cacheDomain.implementation(), cacheDomain.eviction(), flushInterval, size, cacheDomain.readWrite(), cacheDomain.blocking(), props);
    }
}
```

`<1>` å¤„ï¼Œè·å¾—**ç±»**ä¸Šçš„ `@CacheNamespace` æ³¨è§£ã€‚

`<2>` å¤„ï¼Œè·å¾—å„ç§å±æ€§ã€‚

`<3>` å¤„ï¼Œè°ƒç”¨ `#convertToProperties(Property[] properties)` æ–¹æ³•ï¼Œå°† `@Property` æ³¨è§£æ•°ç»„ï¼Œè½¬æ¢æˆ Properties å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private Properties convertToProperties(Property[] properties) {
    if (properties.length == 0) {
        return null;
    }
    Properties props = new Properties();
    for (Property property : properties) {
        props.setProperty(property.name(),
                PropertyParser.parse(property.value(), configuration.getVariables())); // æ›¿æ¢
    }
    return props;
}
```

`<4>` å¤„ï¼Œè°ƒç”¨ `MapperBuilderAssistant#useNewCache(...)` æ–¹æ³•ï¼Œåˆ›å»º Cache å¯¹è±¡ã€‚åœ¨ [ã€Šç²¾å°½ MyBatis æºç åˆ†æ â€”â€” MyBatis åˆå§‹åŒ–ï¼ˆäºŒï¼‰ä¹‹åŠ è½½ Mapper æ˜ å°„é…ç½®æ–‡ä»¶ã€‹](http://svip.iocoder.cn/MyBatis/builder-package-2) çš„ [ã€Œ3.4 useNewCacheã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ä¸­ï¼Œå·²ç»è¯¦ç»†è§£æã€‚

### 2.5 parseCacheRef

`#parseCacheRef()` æ–¹æ³•ï¼Œè§£æ `@CacheNamespaceRef` æ³¨è§£ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private void parseCacheRef() {
    // è·å¾—ç±»ä¸Šçš„ @CacheNamespaceRef æ³¨è§£
    CacheNamespaceRef cacheDomainRef = type.getAnnotation(CacheNamespaceRef.class);
    if (cacheDomainRef != null) {
        // <2> è·å¾—å„ç§å±æ€§
        Class<?> refType = cacheDomainRef.value();
        String refName = cacheDomainRef.name();
        // <2> æ ¡éªŒï¼Œå¦‚æœ refType å’Œ refName éƒ½ä¸ºç©ºï¼Œåˆ™æŠ›å‡º BuilderException å¼‚å¸¸
        if (refType == void.class && refName.isEmpty()) {
            throw new BuilderException("Should be specified either value() or name() attribute in the @CacheNamespaceRef");
        }
        // <2> æ ¡éªŒï¼Œå¦‚æœ refType å’Œ refName éƒ½ä¸ä¸ºç©ºï¼Œåˆ™æŠ›å‡º BuilderException å¼‚å¸¸
        if (refType != void.class && !refName.isEmpty()) {
            throw new BuilderException("Cannot use both value() and name() attribute in the @CacheNamespaceRef");
        }
        // <2> è·å¾—æœ€ç»ˆçš„ namespace å±æ€§
        String namespace = (refType != void.class) ? refType.getName() : refName;
        // <3> è·å¾—æŒ‡å‘çš„ Cache å¯¹è±¡
        assistant.useCacheRef(namespace);
    }
}
```

`<1>` å¤„ï¼Œè·å¾—**ç±»**ä¸Šçš„ `@CacheNamespaceRef` æ³¨è§£ã€‚

`<2>` å¤„ï¼Œè·å¾—å„ç§å±æ€§ï¼Œè¿›è¡Œæ ¡éªŒï¼Œæœ€ç»ˆè·å¾— `namespace` å±æ€§ã€‚

`<3>` å¤„ï¼Œè°ƒç”¨ `MapperBuilderAssistant#useCacheRef(String namespace)` æ–¹æ³•ï¼Œè·å¾—æŒ‡å‘çš„ Cache å¯¹è±¡ã€‚åœ¨ [ã€Šç²¾å°½ MyBatis æºç åˆ†æ â€”â€” MyBatis åˆå§‹åŒ–ï¼ˆäºŒï¼‰ä¹‹åŠ è½½ Mapper æ˜ å°„é…ç½®æ–‡ä»¶ã€‹](http://svip.iocoder.cn/MyBatis/builder-package-2) çš„ [ã€Œ3.3 useCacheRefã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ä¸­ï¼Œå·²ç»è¯¦ç»†è§£æã€‚

### 2.6 parseStatement

`#parseStatement(Method method)` æ–¹æ³•ï¼Œè§£ææ–¹æ³•ä¸Šçš„ SQL æ“ä½œç›¸å…³çš„æ³¨è§£ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

void parseStatement(Method method) {
    // <1> è·å¾—å‚æ•°çš„ç±»å‹
    Class<?> parameterTypeClass = getParameterType(method);
    // <2> è·å¾— LanguageDriver å¯¹è±¡
    LanguageDriver languageDriver = getLanguageDriver(method);
    // <3> è·å¾— SqlSource å¯¹è±¡
    SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver);
    if (sqlSource != null) {
        // <4> è·å¾—å„ç§å±æ€§
        Options options = method.getAnnotation(Options.class);
        final String mappedStatementId = type.getName() + "." + method.getName();
        Integer fetchSize = null;
        Integer timeout = null;
        StatementType statementType = StatementType.PREPARED;
        ResultSetType resultSetType = null;
        SqlCommandType sqlCommandType = getSqlCommandType(method);
        boolean isSelect = sqlCommandType == SqlCommandType.SELECT;
        boolean flushCache = !isSelect;
        boolean useCache = isSelect;

        // <5> è·å¾— KeyGenerator å¯¹è±¡
        KeyGenerator keyGenerator;
        String keyProperty = null;
        String keyColumn = null;
        if (SqlCommandType.INSERT.equals(sqlCommandType) || SqlCommandType.UPDATE.equals(sqlCommandType)) { // æœ‰
            // first check for SelectKey annotation - that overrides everything else
            // <5.1> å¦‚æœæœ‰ @SelectKey æ³¨è§£ï¼Œåˆ™è¿›è¡Œå¤„ç†
            SelectKey selectKey = method.getAnnotation(SelectKey.class);
            if (selectKey != null) {
                keyGenerator = handleSelectKeyAnnotation(selectKey, mappedStatementId, getParameterType(method), languageDriver);
                keyProperty = selectKey.keyProperty();
            // <5.2> å¦‚æœæ—  @Options æ³¨è§£ï¼Œåˆ™æ ¹æ®å…¨å±€é…ç½®å¤„ç†
            } else if (options == null) {
                keyGenerator = configuration.isUseGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;
            // <5.3> å¦‚æœæœ‰ @Options æ³¨è§£ï¼Œåˆ™ä½¿ç”¨è¯¥æ³¨è§£çš„é…ç½®å¤„ç†
            } else {
                keyGenerator = options.useGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;
                keyProperty = options.keyProperty();
                keyColumn = options.keyColumn();
            }
        // <5.4> æ— 
        } else {
            keyGenerator = NoKeyGenerator.INSTANCE;
        }

        // <6> åˆå§‹åŒ–å„ç§å±æ€§
        if (options != null) {
            if (FlushCachePolicy.TRUE.equals(options.flushCache())) {
                flushCache = true;
            } else if (FlushCachePolicy.FALSE.equals(options.flushCache())) {
                flushCache = false;
            }
            useCache = options.useCache();
            fetchSize = options.fetchSize() > -1 || options.fetchSize() == Integer.MIN_VALUE ? options.fetchSize() : null; //issue #348
            timeout = options.timeout() > -1 ? options.timeout() : null;
            statementType = options.statementType();
            resultSetType = options.resultSetType();
        }

        // <7> è·å¾— resultMapId ç¼–å·å­—ç¬¦ä¸²
        String resultMapId = null;
        // <7.1> å¦‚æœæœ‰ @ResultMap æ³¨è§£ï¼Œä½¿ç”¨è¯¥æ³¨è§£ä¸º resultMapId å±æ€§
        ResultMap resultMapAnnotation = method.getAnnotation(ResultMap.class);
        if (resultMapAnnotation != null) {
            String[] resultMaps = resultMapAnnotation.value();
            StringBuilder sb = new StringBuilder();
            for (String resultMap : resultMaps) {
                if (sb.length() > 0) {
                    sb.append(",");
                }
                sb.append(resultMap);
            }
            resultMapId = sb.toString();
        // <7.2> å¦‚æœæ—  @ResultMap æ³¨è§£ï¼Œè§£æå…¶å®ƒæ³¨è§£ï¼Œä½œä¸º resultMapId å±æ€§
        } else if (isSelect) {
            resultMapId = parseResultMap(method);
        }

        // æ„å»º MappedStatement å¯¹è±¡
        assistant.addMappedStatement(
                mappedStatementId,
                sqlSource,
                statementType,
                sqlCommandType,
                fetchSize,
                timeout,
                // ParameterMapID
                null,
                parameterTypeClass,
                resultMapId,
                getReturnType(method), // è·å¾—è¿”å›ç±»å‹
                resultSetType,
                flushCache,
                useCache,
                // TODO gcode issue #577
                false,
                keyGenerator,
                keyProperty,
                keyColumn,
                // DatabaseID
                null,
                languageDriver,
                // ResultSets
                options != null ? nullOrEmpty(options.resultSets()) : null);
    }
}
```

`<1>` å¤„ï¼Œè°ƒç”¨ `#getParameterType(Method method)` æ–¹æ³•ï¼Œè·å¾—å‚æ•°çš„ç±»å‹ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.6.1 getParameterTypeã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

`<2>` å¤„ï¼Œè°ƒç”¨ `#getLanguageDriver(Method method)` æ–¹æ³•ï¼Œè·å¾— LanguageDriver å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.6.2 getLanguageDriverã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

`<3>` å¤„ï¼Œè°ƒç”¨ `#getSqlSourceFromAnnotations(...)` æ–¹æ³•ï¼Œä»æ³¨è§£ä¸­ï¼Œè·å¾— SqlSource å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.6.3 getSqlSourceFromAnnotationsã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

`<4>` å¤„ï¼Œè·å¾—å„ç§å±æ€§ã€‚

`<5>` å¤„ï¼Œè·å¾— KeyGenerator å¯¹è±¡ã€‚

- `<5.1>` å¤„ï¼Œå¦‚æœæœ‰ `@SelectKey` æ³¨è§£ï¼Œåˆ™è°ƒç”¨ `#handleSelectKeyAnnotation(...)` æ–¹æ³•ï¼Œå¤„ç† `@@SelectKey` æ³¨è§£ï¼Œç”Ÿæˆå¯¹åº”çš„ SelectKey å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.6.4 handleSelectKeyAnnotationã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚
- `<5.2>` å¤„ï¼Œå¦‚æœæ—  `@Options` æ³¨è§£ï¼Œåˆ™æ ¹æ®å…¨å±€é…ç½®å¤„ç†ï¼Œä½¿ç”¨ Jdbc3KeyGenerator æˆ– NoKeyGenerator å•ä¾‹ã€‚
- `<5.3>` å¤„ï¼Œå¦‚æœæœ‰ `@Options` æ³¨è§£ï¼Œåˆ™ä½¿ç”¨è¯¥æ³¨è§£çš„é…ç½®å¤„ç†ã€‚
- `<5.4>` å¤„ï¼Œéæ’å…¥å’Œæ›´æ–°è¯­å¥ï¼Œæ— éœ€ KeyGenerator å¯¹è±¡ï¼Œæ‰€ä»¥ä½¿ç”¨ NoKeyGenerator å•ä¾‹ã€‚

`<6>` å¤„ï¼Œåˆå§‹åŒ–å„ç§å±æ€§ã€‚

`<7>` å¤„ï¼Œè·å¾— `resultMapId` ç¼–å·å­—ç¬¦ä¸²ã€‚

`<7.1>` å¤„ï¼Œå¦‚æœæœ‰ `@ResultMap` æ³¨è§£ï¼Œä½¿ç”¨è¯¥æ³¨è§£ä¸º `resultMapId` å±æ€§ã€‚å› ä¸º `@ResultMap` æ³¨è§£çš„ä½œç”¨ï¼Œå°±æ˜¯æ³¨è§£ä½¿ç”¨çš„ç»“æœé›†ã€‚

`<7.2>` å¤„ï¼Œå¦‚æœæ—  `@ResultMap` æ³¨è§£ï¼Œè°ƒç”¨ `#parseResultMap(Method method)` æ–¹æ³•ï¼Œè§£æå…¶å®ƒæ³¨è§£ï¼Œä½œä¸º `resultMapId` å±æ€§ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.6.6 parseResultMapã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

#### 2.6.1 getParameterType

è°ƒç”¨ `#getParameterType(Method method)` æ–¹æ³•ï¼Œè·å¾—å‚æ•°çš„ç±»å‹ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private Class<?> getParameterType(Method method) {
    Class<?> parameterType = null;
    // éå†å‚æ•°ç±»å‹æ•°ç»„
    // æ’é™¤ RowBounds å’Œ ResultHandler ä¸¤ç§å‚æ•°
    // 1. å¦‚æœæ˜¯å¤šå‚æ•°ï¼Œåˆ™æ˜¯ ParamMap ç±»å‹
    // 2. å¦‚æœæ˜¯å•å‚æ•°ï¼Œåˆ™æ˜¯è¯¥å‚æ•°çš„ç±»å‹
    Class<?>[] parameterTypes = method.getParameterTypes();
    for (Class<?> currentParameterType : parameterTypes) {
        if (!RowBounds.class.isAssignableFrom(currentParameterType) && !ResultHandler.class.isAssignableFrom(currentParameterType)) {
            if (parameterType == null) {
                parameterType = currentParameterType;
            } else {
                // issue #135
                parameterType = ParamMap.class;
            }
        }
    }
    return parameterType;
}
```

æ¯”è¾ƒç®€å•ï¼Œæ ¹æ®æ˜¯å¦ä¸ºå¤šå‚æ•°ï¼Œè¿”å›æ˜¯ ParamMap ç±»å‹ï¼Œè¿˜æ˜¯å•å‚æ•°å¯¹åº”çš„ç±»å‹ã€‚

#### 2.6.2 getLanguageDriver

`#getLanguageDriver(Method method)` æ–¹æ³•ï¼Œè·å¾— LanguageDriver å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private LanguageDriver getLanguageDriver(Method method) {
    // è§£æ @Lang æ³¨è§£ï¼Œè·å¾—å¯¹åº”çš„ç±»å‹
    Lang lang = method.getAnnotation(Lang.class);
    Class<? extends LanguageDriver> langClass = null;
    if (lang != null) {
        langClass = lang.value();
    }
    // è·å¾— LanguageDriver å¯¹è±¡
    // å¦‚æœ langClass ä¸ºç©ºï¼Œå³æ—  @Lang æ³¨è§£ï¼Œåˆ™ä¼šä½¿ç”¨é»˜è®¤ LanguageDriver ç±»å‹
    return assistant.getLanguageDriver(langClass);
}
```

è°ƒç”¨ `MapperBuilderAssistant#getLanguageDriver(Class<? extends LanguageDriver> langClass)` æ–¹æ³•ï¼Œè·å¾— LanguageDriver å¯¹è±¡ã€‚åœ¨ [ã€Šç²¾å°½ MyBatis æºç åˆ†æ â€”â€” MyBatis åˆå§‹åŒ–ï¼ˆä¸‰ï¼‰ä¹‹åŠ è½½ Statement é…ç½®ã€‹](http://svip.iocoder.cn/MyBatis/builder-package-3) çš„ [ã€Œ2.4 getLanguageDriverã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ä¸­ï¼Œå·²ç»è¯¦ç»†è§£æã€‚

#### 2.6.3 getSqlSourceFromAnnotations

`#getSqlSourceFromAnnotations(Method method, Class<?> parameterType, LanguageDriver languageDriver)` æ–¹æ³•ï¼Œä»æ³¨è§£ä¸­ï¼Œè·å¾— SqlSource å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private SqlSource getSqlSourceFromAnnotations(Method method, Class<?> parameterType, LanguageDriver languageDriver) {
    try {
        // <1.1> <1.2> è·å¾—æ–¹æ³•ä¸Šçš„ SQL_ANNOTATION_TYPES å’Œ SQL_PROVIDER_ANNOTATION_TYPES å¯¹åº”çš„ç±»å‹
        Class<? extends Annotation> sqlAnnotationType = getSqlAnnotationType(method);
        Class<? extends Annotation> sqlProviderAnnotationType = getSqlProviderAnnotationType(method);
        // <2> å¦‚æœ SQL_ANNOTATION_TYPES å¯¹åº”çš„ç±»å‹éç©º
        if (sqlAnnotationType != null) {
            // å¦‚æœ SQL_PROVIDER_ANNOTATION_TYPES å¯¹åº”çš„ç±»å‹éç©ºï¼Œåˆ™æŠ›å‡º BindingException å¼‚å¸¸ï¼Œå› ä¸ºå†²çªäº†ã€‚
            if (sqlProviderAnnotationType != null) {
                throw new BindingException("You cannot supply both a static SQL and SqlProvider to method named " + method.getName());
            }
            // <2.1> è·å¾— SQL_ANNOTATION_TYPES å¯¹åº”çš„æ³¨è§£
            Annotation sqlAnnotation = method.getAnnotation(sqlAnnotationType);
            // <2.2> è·å¾— value å±æ€§
            final String[] strings = (String[]) sqlAnnotation.getClass().getMethod("value").invoke(sqlAnnotation);
            // <2.3> åˆ›å»º SqlSource å¯¹è±¡
            return buildSqlSourceFromStrings(strings, parameterType, languageDriver);
        // <3> å¦‚æœ SQL_PROVIDER_ANNOTATION_TYPES å¯¹åº”çš„ç±»å‹éç©º
        } else if (sqlProviderAnnotationType != null) {
            // <3.1> è·å¾— SQL_PROVIDER_ANNOTATION_TYPES å¯¹åº”çš„æ³¨è§£
            Annotation sqlProviderAnnotation = method.getAnnotation(sqlProviderAnnotationType);
            // <3.2> åˆ›å»º ProviderSqlSource å¯¹è±¡
            return new ProviderSqlSource(assistant.getConfiguration(), sqlProviderAnnotation, type, method);
        }
        // <4> è¿”å›ç©º
        return null;
    } catch (Exception e) {
        throw new BuilderException("Could not find value method on SQL annotation.  Cause: " + e, e);
    }
}
```

`<1.1>` å¤„ï¼Œè°ƒç”¨ `#getSqlAnnotationType(Method method)` æ–¹æ³•ï¼Œè·å¾—æ–¹æ³•ä¸Šçš„ `SQL_ANNOTATION_TYPES` ç±»å‹çš„æ³¨è§£ç±»å‹ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.6.3.1 getSqlAnnotationTypeã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

`<1.2>` å¤„ï¼Œè°ƒç”¨ `#getSqlProviderAnnotationType(Method method)` æ–¹æ³•ï¼Œè·å¾—æ–¹æ³•ä¸Šçš„ `SQL_PROVIDER_ANNOTATION_TYPES` ç±»å‹çš„æ³¨è§£ç±»å‹ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.6.3.2 getSqlAnnotationTypeã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

`<2>` å¤„ï¼Œå¦‚æœ `SQL_ANNOTATION_TYPES` å¯¹åº”çš„ç±»å‹éç©ºçš„æƒ…å†µï¼Œä¾‹å¦‚ `@Insert` æ³¨è§£ï¼š

`<2.1>` å¤„ï¼Œè·å¾— `SQL_ANNOTATION_TYPES` å¯¹åº”çš„æ³¨è§£ã€‚

`<2.2>` å¤„ï¼Œé€šè¿‡åå°„ï¼Œè·å¾—å¯¹åº”çš„ `value` å±æ€§ã€‚å› ä¸ºè¿™é‡Œçš„æ³¨è§£ç±»æœ‰å¤šç§ï¼Œæ‰€ä»¥åªå¥½é€šè¿‡åå°„æ–¹æ³•æ¥è·å–è¯¥å±æ€§ã€‚

`<2.3>` å¤„ï¼Œè°ƒç”¨ `#buildSqlSourceFromStrings(...)` æ–¹æ³•ï¼Œåˆ›å»º SqlSource å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.6.3.3 buildSqlSourceFromStringsã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

`<3>` å¤„ï¼Œå¦‚æœ `SQL_PROVIDER_ANNOTATION_TYPES` å¯¹åº”çš„ç±»å‹éç©ºçš„æƒ…å†µï¼Œä¾‹å¦‚ `@InsertProvider` æ³¨è§£ï¼š

`<3.1>` å¤„ï¼Œè·å¾— `SQL_PROVIDER_ANNOTATION_TYPES` å¯¹åº”çš„æ³¨è§£ã€‚

`<3.2>` å¤„ï¼Œåˆ›å»º ProviderSqlSource å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§åç»­çš„æ–‡ç« ã€‚

`<4>` å¤„ï¼Œæ²¡æœ‰ç©ºï¼Œæ²¡æœ‰ç¬¦åˆçš„æ³¨è§£ã€‚

##### 2.6.3.1 getSqlAnnotationType

`#getSqlAnnotationType(Method method)` æ–¹æ³•ï¼Œè·å¾—æ–¹æ³•ä¸Šçš„ `SQL_ANNOTATION_TYPES` ç±»å‹çš„æ³¨è§£ç±»å‹ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private Class<? extends Annotation> getSqlAnnotationType(Method method) {
    return chooseAnnotationType(method, SQL_ANNOTATION_TYPES);
}

/**
 * è·å¾—ç¬¦åˆæŒ‡å®šç±»å‹çš„æ³¨è§£ç±»å‹
 *
 * @param method æ–¹æ³•
 * @param types æŒ‡å®šç±»å‹
 * @return æŸ¥åˆ°çš„æ³¨è§£ç±»å‹
 */
private Class<? extends Annotation> chooseAnnotationType(Method method, Set<Class<? extends Annotation>> types) {
    for (Class<? extends Annotation> type : types) {
        Annotation annotation = method.getAnnotation(type);
        if (annotation != null) {
            return type;
        }
    }
    return null;
}
```

##### 2.6.3.2 getSqlProviderAnnotationType

`#getSqlProviderAnnotationType(Method method)` æ–¹æ³•ï¼Œè·å¾—æ–¹æ³•ä¸Šçš„ `SQL_ANNOTATION_TYPES` ç±»å‹çš„æ³¨è§£ç±»å‹ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private Class<? extends Annotation> getSqlProviderAnnotationType(Method method) {
    return chooseAnnotationType(method, SQL_PROVIDER_ANNOTATION_TYPES);
}
```

##### 2.6.3.3 buildSqlSourceFromStrings

`#buildSqlSourceFromStrings(String[] strings, Class<?> parameterTypeClass, LanguageDriver languageDriver)` æ–¹æ³•ï¼Œåˆ›å»º SqlSource å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private SqlSource buildSqlSourceFromStrings(String[] strings, Class<?> parameterTypeClass, LanguageDriver languageDriver) {
    // <1> æ‹¼æ¥ SQL
    final StringBuilder sql = new StringBuilder();
    for (String fragment : strings) {
        sql.append(fragment);
        sql.append(" ");
    }
    // <2> åˆ›å»º SqlSource å¯¹è±¡
    return languageDriver.createSqlSource(configuration, sql.toString().trim(), parameterTypeClass);
}
```

`<1>` å¤„ï¼Œæ‹¼æ¥ SQL ï¼Œä½¿ç”¨ `" "` ç©ºæ ¼åˆ†éš”ã€‚å› ä¸ºï¼Œ`@Select` ç­‰æ³¨è§£ï¼Œ`value` å±æ€§æ˜¯ä¸ª**æ•°ç»„**ã€‚

`<2>` å¤„ï¼Œè°ƒç”¨ `LanguageDriver#createSqlSource(Configuration configuration, String script, Class<?> parameterType)` æ–¹æ³•ï¼Œåˆ›å»º SqlSource å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§åç»­æ–‡ç« ã€‚

#### 2.6.4 handleSelectKeyAnnotation

`#handleSelectKeyAnnotation(SelectKey selectKeyAnnotation, String baseStatementId, Class<?> parameterTypeClass, LanguageDriver languageDriver)` æ–¹æ³•ï¼Œå¤„ç† `@@SelectKey` æ³¨è§£ï¼Œç”Ÿæˆå¯¹åº”çš„ SelectKey å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private KeyGenerator handleSelectKeyAnnotation(SelectKey selectKeyAnnotation, String baseStatementId, Class<?> parameterTypeClass, LanguageDriver languageDriver) {
    // è·å¾—å„ç§å±æ€§å’Œå¯¹åº”çš„ç±»
    String id = baseStatementId + SelectKeyGenerator.SELECT_KEY_SUFFIX;
    Class<?> resultTypeClass = selectKeyAnnotation.resultType();
    StatementType statementType = selectKeyAnnotation.statementType();
    String keyProperty = selectKeyAnnotation.keyProperty();
    String keyColumn = selectKeyAnnotation.keyColumn();
    boolean executeBefore = selectKeyAnnotation.before();

    // defaults
    // åˆ›å»º MappedStatement éœ€è¦ç”¨åˆ°çš„é»˜è®¤å€¼
    boolean useCache = false;
    KeyGenerator keyGenerator = NoKeyGenerator.INSTANCE;
    Integer fetchSize = null;
    Integer timeout = null;
    boolean flushCache = false;
    String parameterMap = null;
    String resultMap = null;
    ResultSetType resultSetTypeEnum = null;

    // åˆ›å»º SqlSource å¯¹è±¡
    SqlSource sqlSource = buildSqlSourceFromStrings(selectKeyAnnotation.statement(), parameterTypeClass, languageDriver);
    SqlCommandType sqlCommandType = SqlCommandType.SELECT;

    // åˆ›å»º MappedStatement å¯¹è±¡
    assistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType, fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass, resultSetTypeEnum,
            flushCache, useCache, false,
            keyGenerator, keyProperty, keyColumn, null, languageDriver, null);

    // è·å¾— SelectKeyGenerator çš„ç¼–å·ï¼Œæ ¼å¼ä¸º `${namespace}.${id}`
    id = assistant.applyCurrentNamespace(id, false);
    // è·å¾— MappedStatement å¯¹è±¡
    MappedStatement keyStatement = configuration.getMappedStatement(id, false);
    // åˆ›å»º SelectKeyGenerator å¯¹è±¡ï¼Œå¹¶æ·»åŠ åˆ° configuration ä¸­
    SelectKeyGenerator answer = new SelectKeyGenerator(keyStatement, executeBefore);
    configuration.addKeyGenerator(id, answer);
    return answer;
}
```

ä»å®ç°é€»è¾‘ä¸Šï¼Œæˆ‘ä»¬ä¼šå‘ç°ï¼Œå’Œ `XMLStatementBuilder#parseSelectKeyNode(String id, XNode nodeToHandle, Class<?> parameterTypeClass, LanguageDriver langDriver, String databaseId)` æ–¹æ³•æ˜¯**ä¸€è‡´**çš„ã€‚æ‰€ä»¥å°±ä¸é‡å¤è§£æäº†ï¼Œèƒ–å‹å¯ä»¥çœ‹çœ‹ [ã€Šç²¾å°½ MyBatis æºç åˆ†æ â€”â€” MyBatis åˆå§‹åŒ–ï¼ˆä¸‰ï¼‰ä¹‹åŠ è½½ Statement é…ç½®ã€‹](http://svip.iocoder.cn/MyBatis/builder-package-3) çš„ [ã€Œ2.5.2 parseSelectKeyNodeã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

#### 2.6.5 getSqlCommandType

`#getSqlCommandType(Method method)` æ–¹æ³•ï¼Œè·å¾—æ–¹æ³•å¯¹åº”çš„ SQL å‘½ä»¤ç±»å‹ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private SqlCommandType getSqlCommandType(Method method) {
    // è·å¾—ç¬¦åˆ SQL_ANNOTATION_TYPES ç±»å‹çš„æ³¨è§£ç±»å‹
    Class<? extends Annotation> type = getSqlAnnotationType(method);

    if (type == null) {
        // è·å¾—ç¬¦åˆ SQL_PROVIDER_ANNOTATION_TYPES ç±»å‹çš„æ³¨è§£ç±»å‹
        type = getSqlProviderAnnotationType(method);

        // æ‰¾ä¸åˆ°ï¼Œè¿”å› SqlCommandType.UNKNOWN
        if (type == null) {
            return SqlCommandType.UNKNOWN;
        }

        // è½¬æ¢æˆå¯¹åº”çš„æšä¸¾
        if (type == SelectProvider.class) {
            type = Select.class;
        } else if (type == InsertProvider.class) {
            type = Insert.class;
        } else if (type == UpdateProvider.class) {
            type = Update.class;
        } else if (type == DeleteProvider.class) {
            type = Delete.class;
        }
    }

    // è½¬æ¢æˆå¯¹åº”çš„æšä¸¾
    return SqlCommandType.valueOf(type.getSimpleName().toUpperCase(Locale.ENGLISH));
}
```

#### 2.6.6 parseResultMap

`#parseResultMap(Method method)` æ–¹æ³•ï¼Œè§£æå…¶å®ƒæ³¨è§£ï¼Œè¿”å› `resultMapId` å±æ€§ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private String parseResultMap(Method method) {
    // <1> è·å¾—è¿”å›ç±»å‹
    Class<?> returnType = getReturnType(method);
    // <2> è·å¾— @ConstructorArgsã€@Resultsã€@TypeDiscriminator æ³¨è§£
    ConstructorArgs args = method.getAnnotation(ConstructorArgs.class);
    Results results = method.getAnnotation(Results.class);
    TypeDiscriminator typeDiscriminator = method.getAnnotation(TypeDiscriminator.class);
    // <3> ç”Ÿæˆ resultMapId
    String resultMapId = generateResultMapName(method);
    // <4> ç”Ÿæˆ ResultMap å¯¹è±¡
    applyResultMap(resultMapId, returnType, argsIf(args), resultsIf(results), typeDiscriminator);
    return resultMapId;
}
```

`<1>` å¤„ï¼Œè°ƒç”¨ `#getReturnType(Method method)` æ–¹æ³•ï¼Œè·å¾—è¿”å›ç±»å‹ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.6.6.1 getReturnTypeã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

`<2>` å¤„ï¼Œè·å¾— `@ConstructorArgs`ã€`@Results`ã€`@TypeDiscriminator` æ³¨è§£ã€‚

`<3>` å¤„ï¼Œè°ƒç”¨ `#generateResultMapName(Method method)` æ–¹æ³•ï¼Œç”Ÿæˆ `resultMapId` ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.6.6.2 generateResultMapNameã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

`<4>` å¤„ï¼Œè°ƒç”¨ `#argsIf(ConstructorArgs args)` æ–¹æ³•ï¼Œè·å¾— `@ConstructorArgs` æ³¨è§£çš„ `@Arg[]` æ•°ç»„ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private Arg[] argsIf(ConstructorArgs args) {
    return args == null ? new Arg[0] : args.value();
}
```

`<4>` å¤„ï¼Œè°ƒç”¨ `#resultsIf((Results results)` æ–¹æ³•ï¼Œè·å¾— `@(Results` æ³¨è§£çš„ `@Result[]` æ•°ç»„ã€‚

```java
// MapperAnnotationBuilder.java

private Result[] resultsIf(Results results) {
    return results == null ? new Result[0] : results.value();
}
```

`<4>` å¤„ï¼Œè°ƒç”¨ `#applyResultMap(...)` æ–¹æ³•ï¼Œç”Ÿæˆ ResultMap å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.6.6.3 applyResultMapã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

##### 2.6.6.1 getReturnType

`#getReturnType(Method method)` æ–¹æ³•ï¼Œè·å¾—è¿”å›ç±»å‹ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private Class<?> getReturnType(Method method) {
    // è·å¾—æ–¹æ³•çš„è¿”å›ç±»å‹
    Class<?> returnType = method.getReturnType();
    // è§£ææˆå¯¹åº”çš„ Type
    Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, type);
    // å¦‚æœ Type æ˜¯ Class ï¼Œæ™®é€šç±»
    if (resolvedReturnType instanceof Class) {
        returnType = (Class<?>) resolvedReturnType;
        // å¦‚æœæ˜¯æ•°ç»„ç±»å‹ï¼Œåˆ™ä½¿ç”¨ componentType
        if (returnType.isArray()) {
            returnType = returnType.getComponentType();
        }
        // gcode issue #508
        // å¦‚æœè¿”å›ç±»å‹æ˜¯ void ï¼Œåˆ™å°è¯•ä½¿ç”¨ @ResultType æ³¨è§£
        if (void.class.equals(returnType)) {
            ResultType rt = method.getAnnotation(ResultType.class);
            if (rt != null) {
                returnType = rt.value();
            }
        }
    // å¦‚æœ Type æ˜¯ ParameterizedType ï¼Œæ³›å‹
    } else if (resolvedReturnType instanceof ParameterizedType) {
        // è·å¾—æ³›å‹ rawType
        ParameterizedType parameterizedType = (ParameterizedType) resolvedReturnType;
        Class<?> rawType = (Class<?>) parameterizedType.getRawType();
        // å¦‚æœæ˜¯ Collection æˆ–è€… Cursor ç±»å‹æ—¶
        if (Collection.class.isAssignableFrom(rawType) || Cursor.class.isAssignableFrom(rawType)) {
            // è·å¾— <> ä¸­å®é™…ç±»å‹
            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
            // å¦‚æœ actualTypeArguments çš„å¤§å°ä¸º 1 ï¼Œè¿›ä¸€æ­¥å¤„ç†
            if (actualTypeArguments != null && actualTypeArguments.length == 1) {
                Type returnTypeParameter = actualTypeArguments[0];
                // å¦‚æœæ˜¯ Class ï¼Œåˆ™ç›´æ¥ä½¿ç”¨ Class
                if (returnTypeParameter instanceof Class<?>) {
                    returnType = (Class<?>) returnTypeParameter;
                // å¦‚æœæ˜¯ ParameterizedType ï¼Œåˆ™è·å– <> ä¸­å®é™…ç±»å‹
                } else if (returnTypeParameter instanceof ParameterizedType) {
                    // (gcode issue #443) actual type can be a also a parameterized type
                    returnType = (Class<?>) ((ParameterizedType) returnTypeParameter).getRawType();
                // å¦‚æœæ˜¯æ³›å‹æ•°ç»„ç±»å‹ï¼Œåˆ™è·å¾— genericComponentType å¯¹åº”çš„ç±»
                } else if (returnTypeParameter instanceof GenericArrayType) {
                    Class<?> componentType = (Class<?>) ((GenericArrayType) returnTypeParameter).getGenericComponentType();
                    // (gcode issue #525) support List<byte[]>
                    returnType = Array.newInstance(componentType, 0).getClass();
                }
            }
        // å¦‚æœæœ‰ @MapKey æ³¨è§£ï¼Œå¹¶ä¸”æ˜¯ Map ç±»å‹
        } else if (method.isAnnotationPresent(MapKey.class) && Map.class.isAssignableFrom(rawType)) {
            // (gcode issue 504) Do not look into Maps if there is not MapKey annotation
            // è·å¾— <> ä¸­å®é™…ç±»å‹
            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
            // å¦‚æœ actualTypeArguments çš„å¤§å°ä¸º 2 ï¼Œè¿›ä¸€æ­¥å¤„ç†ã€‚
            // ä¸ºä»€ä¹ˆæ˜¯ 2 ï¼Œå› ä¸º Map<K, V> å‘€ï¼Œæœ‰ Kã€V ä¸¤ä¸ªæ³›å‹
            if (actualTypeArguments != null && actualTypeArguments.length == 2) {
                // å¤„ç† V æ³›å‹
                Type returnTypeParameter = actualTypeArguments[1];
                // å¦‚æœ V æ³›å‹ä¸º Class ï¼Œåˆ™ç›´æ¥ä½¿ç”¨ Class
                if (returnTypeParameter instanceof Class<?>) {
                    returnType = (Class<?>) returnTypeParameter;
                // å¦‚æœ V æ³›å‹ä¸º ParameterizedType ï¼Œåˆ™è·å– <> ä¸­å®é™…ç±»å‹
                } else if (returnTypeParameter instanceof ParameterizedType) {
                    // (gcode issue 443) actual type can be a also a parameterized type
                    returnType = (Class<?>) ((ParameterizedType) returnTypeParameter).getRawType();
                }
            }
        // å¦‚æœæ˜¯ Optional ç±»å‹æ—¶
        } else if (Optional.class.equals(rawType)) {
            // è·å¾— <> ä¸­å®é™…ç±»å‹
            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
            // å› ä¸ºæ˜¯ Optional<T> ç±»å‹ï¼Œæ‰€ä»¥ actualTypeArguments æ•°ç»„å¤§å°æ˜¯ä¸€
            Type returnTypeParameter = actualTypeArguments[0];
            // å¦‚æœ <T> æ³›å‹ä¸º Class ï¼Œåˆ™ç›´æ¥ä½¿ç”¨ Class
            if (returnTypeParameter instanceof Class<?>) {
                returnType = (Class<?>) returnTypeParameter;
            }
        }
    }

    return returnType;
}
```

æ–¹æ³•éå¸¸çš„é•¿ï¼Œä¸»è¦æ˜¯è¿›ä¸€æ­¥å¤„ç†æ–¹æ³•çš„è¿”å›ç±»å‹ `Method.returnType` ï¼Œä¾‹å¦‚æ˜¯æ•°ç»„ç±»å‹ã€æ³›å‹ç±»å‹ã€æœ‰ `@MapKey` æ³¨è§£ï¼Œæˆ–æ˜¯ Optional ç±»å‹ï¼Œç­‰ç­‰æƒ…å†µã€‚

##### 2.6.6.2 generateResultMapName

`#generateResultMapName(Method method)` æ–¹æ³•ï¼Œç”Ÿæˆ `resultMapId` ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private String generateResultMapName(Method method) {
    // ç¬¬ä¸€ç§æƒ…å†µï¼Œå·²ç»å£°æ˜
    // å¦‚æœæœ‰ @Results æ³¨è§£ï¼Œå¹¶ä¸”æœ‰è®¾ç½® id å±æ€§ï¼Œåˆ™ç›´æ¥è¿”å›ã€‚æ ¼å¼ä¸ºï¼š`${type.name}.${Results.id}` ã€‚
    Results results = method.getAnnotation(Results.class);
    if (results != null && !results.id().isEmpty()) {
        return type.getName() + "." + results.id();
    }
    // ç¬¬äºŒç§æƒ…å†µï¼Œè‡ªåŠ¨ç”Ÿæˆ
    // è·å¾— suffix å‰ç¼€ï¼Œç›¸å½“äºæ–¹æ³•å‚æ•°æ„æˆçš„ç­¾å
    StringBuilder suffix = new StringBuilder();
    for (Class<?> c : method.getParameterTypes()) {
        suffix.append("-");
        suffix.append(c.getSimpleName());
    }
    if (suffix.length() < 1) {
        suffix.append("-void");
    }
    // æ‹¼æ¥è¿”å›ã€‚æ ¼å¼ä¸º `${type.name}.${method.name}${suffix}` ã€‚
    return type.getName() + "." + method.getName() + suffix;
}
```

åˆ†æˆä¸¤ç§æƒ…å†µï¼šå·²ç»å£°æ˜å’Œè‡ªåŠ¨ç”Ÿæˆã€‚

##### 2.6.6.3 applyResultMap

`#applyResultMap(String resultMapId, Class<?> returnType, Arg[] args, Result[] results, TypeDiscriminator discriminator)` æ–¹æ³•ï¼Œåˆ›å»º ResultMap å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private void applyResultMap(String resultMapId, Class<?> returnType, Arg[] args, Result[] results, TypeDiscriminator discriminator) {
    // <1> åˆ›å»º ResultMapping æ•°ç»„
    List<ResultMapping> resultMappings = new ArrayList<>();
    // <2> å°† @Arg[] æ³¨è§£æ•°ç»„ï¼Œè§£ææˆå¯¹åº”çš„ ResultMapping å¯¹è±¡ä»¬ï¼Œå¹¶æ·»åŠ åˆ° resultMappings ä¸­ã€‚
    applyConstructorArgs(args, returnType, resultMappings);
    // <3> å°† @Result[] æ³¨è§£æ•°ç»„ï¼Œè§£ææˆå¯¹åº”çš„ ResultMapping å¯¹è±¡ä»¬ï¼Œå¹¶æ·»åŠ åˆ° resultMappings ä¸­ã€‚
    applyResults(results, returnType, resultMappings);
    // <4> åˆ›å»º Discriminator å¯¹è±¡
    Discriminator disc = applyDiscriminator(resultMapId, returnType, discriminator);
    // TODO add AutoMappingBehaviour
    // <5> ResultMap å¯¹è±¡
    assistant.addResultMap(resultMapId, returnType, null, disc, resultMappings, null);
    // <6> åˆ›å»º Discriminator çš„ ResultMap å¯¹è±¡ä»¬
    createDiscriminatorResultMaps(resultMapId, returnType, discriminator);
}
```

`<1>` å¤„ï¼Œåˆ›å»º ResultMapping æ•°ç»„ã€‚

`<2>` å¤„ï¼Œè°ƒç”¨ `#applyConstructorArgs(...)` æ–¹æ³•ï¼Œå°† `@Arg[]` æ³¨è§£æ•°ç»„ï¼Œè§£ææˆå¯¹åº”çš„ ResultMapping å¯¹è±¡ä»¬ï¼Œå¹¶æ·»åŠ åˆ° `resultMappings` ä¸­ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.6.6.3.1 applyConstructorArgsã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

`<3>` å¤„ï¼Œè°ƒç”¨ `#applyResults(...)` æ–¹æ³•ï¼Œå°† `@Result[]` æ³¨è§£æ•°ç»„ï¼Œè§£ææˆå¯¹åº”çš„ ResultMapping å¯¹è±¡ä»¬ï¼Œå¹¶æ·»åŠ åˆ° `resultMappings` ä¸­ã€‚ è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.6.6.3.2 applyResultsã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

`<4>` å¤„ï¼Œè°ƒç”¨ `#applyDiscriminator(...)` æ–¹æ³•ï¼Œåˆ›å»º Discriminator å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.6.6.3.3 applyDiscriminatorã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

`<5>` å¤„ï¼Œè°ƒç”¨ `MapperAnnotationBuilder#addResultMap(...)` æ–¹æ³•ï¼Œåˆ›å»º ResultMap å¯¹è±¡ã€‚

`<6>` å¤„ï¼Œè°ƒç”¨ `#createDiscriminatorResultMaps(...)` æ–¹æ³•ï¼Œåˆ›å»º Discriminator çš„ ResultMap å¯¹è±¡ä»¬ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ2.6.6.3.4 createDiscriminatorResultMapsã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

çœ‹å®Œä¸Šè¿°é€»è¾‘åï¼Œä½ ä¼šå‘ç°è¯¥æ–¹æ³•ï¼Œå’Œ `XMLMapperBuilder#resultMapElement(XNode resultMapNode, List<ResultMapping> additionalResultMappings)` æ–¹æ³•æ˜¯ç±»ä¼¼çš„ã€‚

###### 2.6.6.3.1 applyConstructorArgs

`#applyConstructorArgs(...)` æ–¹æ³•ï¼Œå°† `@Arg[]` æ³¨è§£æ•°ç»„ï¼Œè§£ææˆå¯¹åº”çš„ ResultMapping å¯¹è±¡ä»¬ï¼Œå¹¶æ·»åŠ åˆ° `resultMappings` ä¸­ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private void applyConstructorArgs(Arg[] args, Class<?> resultType, List<ResultMapping> resultMappings) {
    // éå† @Arg[] æ•°ç»„
    for (Arg arg : args) {
        // åˆ›å»º ResultFlag æ•°ç»„
        List<ResultFlag> flags = new ArrayList<>();
        flags.add(ResultFlag.CONSTRUCTOR);
        if (arg.id()) {
            flags.add(ResultFlag.ID);
        }
        @SuppressWarnings("unchecked")
        // è·å¾— TypeHandler ä¹
        Class<? extends TypeHandler<?>> typeHandler = (Class<? extends TypeHandler<?>>)
                (arg.typeHandler() == UnknownTypeHandler.class ? null : arg.typeHandler());
        // å°†å½“å‰ @Arg æ³¨è§£æ„å»ºæˆ ResultMapping å¯¹è±¡
        ResultMapping resultMapping = assistant.buildResultMapping(
                resultType,
                nullOrEmpty(arg.name()),
                nullOrEmpty(arg.column()),
                arg.javaType() == void.class ? null : arg.javaType(),
                arg.jdbcType() == JdbcType.UNDEFINED ? null : arg.jdbcType(),
                nullOrEmpty(arg.select()),
                nullOrEmpty(arg.resultMap()),
                null,
                nullOrEmpty(arg.columnPrefix()),
                typeHandler,
                flags,
                null,
                null,
                false);
        // æ·»åŠ åˆ° resultMappings ä¸­
        resultMappings.add(resultMapping);
    }
}
```

ä»å®ç°é€»è¾‘ä¸Šï¼Œæˆ‘ä»¬ä¼šå‘ç°ï¼Œå’Œ `XMLMapperBuilder#processConstructorElement(XNode resultChild, Class<?> resultType, List<ResultMapping> resultMappings)` æ–¹æ³•æ˜¯**ä¸€è‡´**çš„ã€‚æ‰€ä»¥å°±ä¸é‡å¤è§£æäº†ï¼Œèƒ–å‹å¯ä»¥çœ‹çœ‹ [ã€Šç²¾å°½ MyBatis æºç åˆ†æ â€”â€” MyBatis åˆå§‹åŒ–ï¼ˆäºŒï¼‰ä¹‹åŠ è½½ Mapper æ˜ å°„é…ç½®ã€‹](http://svip.iocoder.cn/MyBatis/builder-package-2) çš„ [ã€Œ2.3.3.1 processConstructorElementã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

###### 2.6.6.3.2 applyResults

`#applyResults(Result[] results, Class<?> resultType, List<ResultMapping> resultMappings)` æ–¹æ³•ï¼Œå°† `@Result[]` æ³¨è§£æ•°ç»„ï¼Œè§£ææˆå¯¹åº”çš„ ResultMapping å¯¹è±¡ä»¬ï¼Œå¹¶æ·»åŠ åˆ° `resultMappings` ä¸­ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private void applyResults(Result[] results, Class<?> resultType, List<ResultMapping> resultMappings) {
    // éå† @Result[] æ•°ç»„
    for (Result result : results) {
        // åˆ›å»º ResultFlag æ•°ç»„
        List<ResultFlag> flags = new ArrayList<>();
        if (result.id()) {
            flags.add(ResultFlag.ID);
        }
        @SuppressWarnings("unchecked")
        // è·å¾— TypeHandler ç±»
        Class<? extends TypeHandler<?>> typeHandler = (Class<? extends TypeHandler<?>>)
                ((result.typeHandler() == UnknownTypeHandler.class) ? null : result.typeHandler());
        // æ„å»º ResultMapping å¯¹è±¡
        ResultMapping resultMapping = assistant.buildResultMapping(
                resultType,
                nullOrEmpty(result.property()),
                nullOrEmpty(result.column()),
                result.javaType() == void.class ? null : result.javaType(),
                result.jdbcType() == JdbcType.UNDEFINED ? null : result.jdbcType(),
                hasNestedSelect(result) ? nestedSelectId(result) : null, // <1.1> <1.2> 
                null,
                null,
                null,
                typeHandler,
                flags,
                null,
                null,
                isLazy(result)); // <2>
        // æ·»åŠ åˆ° resultMappings ä¸­
        resultMappings.add(resultMapping);
    }
}
```

ä»å®ç°é€»è¾‘ä¸Šï¼Œæˆ‘ä»¬ä¼šå‘ç°ï¼Œå’Œ `XMLMapperBuilder#buildResultMappingFromContext(XNode context, Class<?> resultType, List<ResultFlag> flags)` æ–¹æ³•æ˜¯**ä¸€è‡´**çš„ã€‚æ‰€ä»¥å°±ä¸é‡å¤è§£æäº†ï¼Œèƒ–å‹å¯ä»¥çœ‹çœ‹ [ã€Šç²¾å°½ MyBatis æºç åˆ†æ â€”â€” MyBatis åˆå§‹åŒ–ï¼ˆäºŒï¼‰ä¹‹åŠ è½½ Mapper æ˜ å°„é…ç½®ã€‹](http://svip.iocoder.cn/MyBatis/builder-package-2) çš„ [ã€Œ2.3.3.3 buildResultMappingFromContextã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

`<1.1>` å¤„ï¼Œè°ƒç”¨ `#hasNestedSelect(Result result)` æ–¹æ³•ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰å†…åµŒçš„æŸ¥è¯¢ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private boolean hasNestedSelect(Result result) {
    if (result.one().select().length() > 0 && result.many().select().length() > 0) {
        throw new BuilderException("Cannot use both @One and @Many annotations in the same @Result");
    }
    // åˆ¤æ–­æœ‰ @One æˆ– @Many æ³¨è§£
    return result.one().select().length() > 0 || result.many().select().length() > 0;
}
```

`<1.2>` å¤„ï¼Œè°ƒç”¨ `#nestedSelectId((Result result)` æ–¹æ³•ï¼Œè°ƒç”¨ `#nestedSelectId(Result result)` æ–¹æ³•ï¼Œè·å¾—å†…åµŒçš„æŸ¥è¯¢ç¼–å·ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private String nestedSelectId(Result result) {
    // å…ˆè·å¾— @One æ³¨è§£
    String nestedSelect = result.one().select();
    // è·å¾—ä¸åˆ°ï¼Œåˆ™å†è·å¾— @Many
    if (nestedSelect.length() < 1) {
        nestedSelect = result.many().select();
    }
    // è·å¾—å†…åµŒæŸ¥è¯¢ç¼–å·ï¼Œæ ¼å¼ä¸º `{type.name}.${select}`
    if (!nestedSelect.contains(".")) {
        nestedSelect = type.getName() + "." + nestedSelect;
    }
    return nestedSelect;
}
```

`<2>` å¤„ï¼Œè°ƒç”¨ `#isLazy(Result result)` æ–¹æ³•ï¼Œåˆ¤æ–­æ˜¯å¦æ‡’åŠ è½½ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private boolean isLazy(Result result) {
    // åˆ¤æ–­æ˜¯å¦å¼€å¯æ‡’åŠ è½½
    boolean isLazy = configuration.isLazyLoadingEnabled();
    // å¦‚æœæœ‰ @One æ³¨è§£ï¼Œåˆ™åˆ¤æ–­æ˜¯å¦æ‡’åŠ è½½
    if (result.one().select().length() > 0 && FetchType.DEFAULT != result.one().fetchType()) {
        isLazy = result.one().fetchType() == FetchType.LAZY;
    // å¦‚æœæœ‰ @Many æ³¨è§£ï¼Œåˆ™åˆ¤æ–­æ˜¯å¦æ‡’åŠ è½½
    } else if (result.many().select().length() > 0 && FetchType.DEFAULT != result.many().fetchType()) {
        isLazy = result.many().fetchType() == FetchType.LAZY;
    }
    return isLazy;
}
```

æ ¹æ®å…¨å±€æ˜¯å¦æ‡’åŠ è½½ + `@One` æˆ– `@Many` æ³¨è§£ã€‚

###### 2.6.6.3.3 applyDiscriminator

`#applyDiscriminator(...)` æ–¹æ³•ï¼Œåˆ›å»º Discriminator å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private Discriminator applyDiscriminator(String resultMapId, Class<?> resultType, TypeDiscriminator discriminator) {
    if (discriminator != null) {
        // è§£æå„ç§å±æ€§
        String column = discriminator.column();
        Class<?> javaType = discriminator.javaType() == void.class ? String.class : discriminator.javaType();
        JdbcType jdbcType = discriminator.jdbcType() == JdbcType.UNDEFINED ? null : discriminator.jdbcType();
        @SuppressWarnings("unchecked")
        // è·å¾— TypeHandler ç±»
        Class<? extends TypeHandler<?>> typeHandler = (Class<? extends TypeHandler<?>>)
                (discriminator.typeHandler() == UnknownTypeHandler.class ? null : discriminator.typeHandler());
        // éå† @Case[] æ³¨è§£æ•°ç»„ï¼Œè§£ææˆ discriminatorMap é›†åˆ
        Case[] cases = discriminator.cases();
        Map<String, String> discriminatorMap = new HashMap<>();
        for (Case c : cases) {
            String value = c.value();
            String caseResultMapId = resultMapId + "-" + value;
            discriminatorMap.put(value, caseResultMapId);
        }
        // åˆ›å»º Discriminator å¯¹è±¡
        return assistant.buildDiscriminator(resultType, column, javaType, jdbcType, typeHandler, discriminatorMap);
    }
    return null;
}
```

ä»å®ç°é€»è¾‘ä¸Šï¼Œæˆ‘ä»¬ä¼šå‘ç°ï¼Œå’Œ `XMLMapperBuilder#processDiscriminatorElement(XNode context, Class<?> resultType, List<ResultMapping> resultMappings)` æ–¹æ³•æ˜¯**ä¸€è‡´**çš„ã€‚æ‰€ä»¥å°±ä¸é‡å¤è§£æäº†ï¼Œèƒ–å‹å¯ä»¥çœ‹çœ‹ [ã€Šç²¾å°½ MyBatis æºç åˆ†æ â€”â€” MyBatis åˆå§‹åŒ–ï¼ˆäºŒï¼‰ä¹‹åŠ è½½ Mapper æ˜ å°„é…ç½®ã€‹](http://svip.iocoder.cn/MyBatis/builder-package-2) çš„ [ã€Œ2.3.3.2 processDiscriminatorElementã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) ã€‚

###### 2.6.6.3.4 createDiscriminatorResultMaps

`#createDiscriminatorResultMaps(...)` æ–¹æ³•ï¼Œåˆ›å»º Discriminator çš„ ResultMap å¯¹è±¡ä»¬ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MapperAnnotationBuilder.java

private void createDiscriminatorResultMaps(String resultMapId, Class<?> resultType, TypeDiscriminator discriminator) {
    if (discriminator != null) {
        // éå† @Case æ³¨è§£
        for (Case c : discriminator.cases()) {
            // åˆ›å»º @Case æ³¨è§£çš„ ResultMap çš„ç¼–å·
            String caseResultMapId = resultMapId + "-" + c.value();
            // åˆ›å»º ResultMapping æ•°ç»„
            List<ResultMapping> resultMappings = new ArrayList<>();
            // issue #136
            // å°† @Arg[] æ³¨è§£æ•°ç»„ï¼Œè§£ææˆå¯¹åº”çš„ ResultMapping å¯¹è±¡ä»¬ï¼Œå¹¶æ·»åŠ åˆ° resultMappings ä¸­ã€‚
            applyConstructorArgs(c.constructArgs(), resultType, resultMappings);
            // å°† @Result[] æ³¨è§£æ•°ç»„ï¼Œè§£ææˆå¯¹åº”çš„ ResultMapping å¯¹è±¡ä»¬ï¼Œå¹¶æ·»åŠ åˆ° resultMappings ä¸­ã€‚
            applyResults(c.results(), resultType, resultMappings);
            // TODO add AutoMappingBehaviour
            // åˆ›å»º ResultMap å¯¹è±¡
            assistant.addResultMap(caseResultMapId, c.type(), resultMapId, null, resultMappings, null);
        }
    }
}
```

é€»è¾‘æ¯”è¾ƒç®€å•ï¼Œéå† `@Case[]` æ³¨è§£æ•°ç»„ï¼Œåˆ›å»ºæ¯ä¸ª `@Case` å¯¹åº”çš„ ResultMap å¯¹è±¡ã€‚

### 2.7 MethodResolver

`org.apache.ibatis.builder.annotation.MethodResolver` ï¼Œæ³¨è§£æ–¹æ³•çš„å¤„ç†å™¨ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
// MethodResolver.java

public class MethodResolver {

    /**
     * MapperAnnotationBuilder å¯¹è±¡
     */
    private final MapperAnnotationBuilder annotationBuilder;
    /**
     * Method æ–¹æ³•
     */
    private final Method method;

    public MethodResolver(MapperAnnotationBuilder annotationBuilder, Method method) {
        this.annotationBuilder = annotationBuilder;
        this.method = method;
    }

    public void resolve() {
        // æ‰§è¡Œæ³¨è§£æ–¹æ³•çš„è§£æ
        annotationBuilder.parseStatement(method);
    }

}
```

åœ¨ `#resolve()` æ–¹æ³•é‡Œï¼Œå¯ä»¥è°ƒç”¨ `MapperAnnotationBuilder#parseStatement(Method method)` æ–¹æ³•ï¼Œæ‰§è¡Œæ³¨è§£æ–¹æ³•çš„è§£æã€‚

### 2.8 parsePendingMethods

`#parsePendingMethods()` æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```java
private void parsePendingMethods() {
    // è·å¾— MethodResolver é›†åˆï¼Œå¹¶éå†è¿›è¡Œå¤„ç†
    Collection<MethodResolver> incompleteMethods = configuration.getIncompleteMethods();
    synchronized (incompleteMethods) {
        Iterator<MethodResolver> iter = incompleteMethods.iterator();
        while (iter.hasNext()) {
            try {
                // æ‰§è¡Œè§£æ
                iter.next().resolve();
                iter.remove();
                iter.remove();
            } catch (IncompleteElementException e) {
                // This method is still missing a resource
            }
        }
    }
}
```

[ã€Šç²¾å°½ MyBatis æºç åˆ†æ â€”â€” MyBatis åˆå§‹åŒ–ï¼ˆäºŒï¼‰ä¹‹åŠ è½½ Mapper æ˜ å°„é…ç½®æ–‡ä»¶ã€‹](http://svip.iocoder.cn/MyBatis/builder-package-2) çš„ [ã€Œ2.5 parsePendingXXXã€](http://svip.iocoder.cn/MyBatis/builder-package-4/#) æ˜¯ä¸€ä¸ªæ€è·¯ã€‚

1ï¼‰è·å¾—å¯¹åº”çš„é›†åˆï¼›2ï¼‰éå†é›†åˆï¼Œæ‰§è¡Œè§£æï¼›3ï¼‰æ‰§è¡ŒæˆåŠŸï¼Œåˆ™ç§»é™¤å‡ºé›†åˆï¼›4ï¼‰æ‰§è¡Œå¤±è´¥ï¼Œå¿½ç•¥å¼‚å¸¸ã€‚

å½“ç„¶ï¼Œå®é™…ä¸Šï¼Œæ­¤å¤„è¿˜æ˜¯å¯èƒ½æœ‰æ‰§è¡Œè§£æå¤±è´¥çš„æƒ…å†µï¼Œä½†æ˜¯éšç€æ¯ä¸€ä¸ª Mapper æ¥å£å¯¹åº”çš„ MapperAnnotationBuilder æ‰§è¡Œä¸€æ¬¡è¿™äº›æ–¹æ³•ï¼Œé€æ­¥é€æ­¥å°±ä¼šè¢«å…¨éƒ¨è§£æå®Œã€‚
